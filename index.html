<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/@gitgraph/js"></script>
  <link rel="stylesheet" href="./style.css">
  <title>Document</title>
</head>

<body>

  <div class="confirmCopy"></div>

  <header>
    <h1 class="main__title">Cheat cheet Git & Github</h1>
  </header>
  <nav>
    <a href="#branch">#BRANCH</a>
    <a href="#checkout">#CHECKOUT</a>
    <a href="#commit">#COMMIT</a>
    <a href="#diff">#DIFF</a>
    <a href="#log">#LOG</a>
    <a href="#push">#PUSH</a>
    <a href="#rebase">#REBASE</a>
    <a href="#reflog">#REFLOG</a>
    <a href="#remote">#REMOTE</a>
    <a href="#reset">#RESET</a>
    <a href="#restore">#RESTORE</a>
    <a href="#revert">#REVERT</a>
    <a href="#stash">#STASH</a>
    <a href="#switch">#SWITCH</a>
    <a href="#tag">#TAG</a>
    <a href="#infos">#MORE</a>
  </nav>

  <!-- 

  &lt;branche&gt;


  <table>
    <thead>
      <tr>
        <th colspan="2">
          <h2></h2>
        </th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><code></code></td>
        <td>
          <pre>
            <b></b>
          </pre>
        </td>
      </tr>
    </tbody>
  </table>
-->
  <main>

    <section>
      <table id="branch">
        <thead>
          <tr>
            <th colspan="2">
              <h2>BRANCH</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git branch</code></td>
            <td>
              <pre>
              <b>Visualiser les branches locales.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git branch -r</code></td>
            <td>
              <pre>
              <b>Visualiser les branches distantes.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git branch -a</code></td>
            <td>
              <pre>
            <b>Visualiser les branches locales et distantes.</b>
          </pre>
            </td>
          </tr>

          <tr>
            <td><code>git branch &lt;branche&gt;</code></td>
            <td>
              <pre>
              <b>Créer une nouvelle branche.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git branch -d &lt;branch&gt;</code></td>
            <td>
              <pre>
              <b> Supprimer la branche en local.</b>
              Se positionner en dehors de celle-ci avant d'entrer la commande.
              Pour forcer la suppression, remplacer <code>-d</code> par <code>-D</code>. Ca sera nécessaire si la branche n'a pas été mergée.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git branch -m</code></td>
            <td>
              <pre>
              <b>Renommer la branche sur laquelle on est positionnée.</b>
            </pre>
            </td>
          </tr>

        </tbody>
      </table>

      <table id="checkout">
        <thead>
          <tr>
            <th colspan="2">
              <h2>CHECKOUT</h2>
            </th>
          </tr>

        <tbody>
          <tr>
            <td><code>git checkout &lt;branche&gt;</code></td>
            <td>
              <pre>
                <b>Changer de branche.</b>
              </pre>
            </td>
          </tr>

          <tr>
            <td><code>git checkout -d &lt;branche&gt;</code></td>
            <td>
              <pre>
                <b>Créer une branche et basculer directement sur celle-ci.</b>
              </pre>
            </td>
          </tr>
        </tbody>
        </thead>


      </table>

      <table id="commit">
        <thead>
          <tr>
            <th colspan="2">
              <h2>COMMIT</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git commit -am "&lt;message&gt;"</code></td>
            <td>
              <pre>
              <b>Stage et commit tous les fichiers modifiés.</b>
              Cela ne remplace pas un <code>git add . </code> suivi d'un commit car le flag <code>-a</code> va stage seulement les fichiers suivis alors que <code>git add . </code> va aussi prendre les nouveaux fichiers en compte.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git commit --amend</code></td>
            <td>
              <pre>
              <b>Remplace le précédent commit.</b>
              Le nouveau commit contiendra les changements qu'on a stage en plus de ceux du précédent commit. Le hash sera différent. Si on veut changer le nom du commit, on peut rajouter <code>-m "&lt;message&gt;"</code>. 
              Au contraire, si on veut juste ajouter des changements en gardant l'ancien message, on peut ajouter <code>--no-edit</code>. Il est possible de changer le nom du commit sans avoir de choses supplémentaires à envoyer.
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="diff">
        <thead>
          <tr>
            <th colspan="2">
              <h2>DIFF</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git diff</code></td>
            <td>
              <pre>
              <b>Voir les changements des fichiers suivis mais pas encore stage.</b>
              Possibilité de rajouter l'argument <code>-w</code> pour ignorer les espaces.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git diff HEAD</code></td>
            <td>
              <pre>
              <b>Voir tous les changements entre les fichiers suivis (qu'ils aient été stage ou non) et HEAD.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git diff --staged</code></td>
            <td>
              <pre>
              <b>Voir les changements entre HEAD ce qui est stage.</b>
              Autre notation : <code>git diff --cached</code>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git diff &lt;fichier1&gt; &lt;fichier2...&gt;</code></td>
            <td>
              <pre>
              <b>Voir les changements dans le où les fichiers ciblés.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git diff &lt;branche1&gt; &lt;branche2&gt;</code></td>
            <td>
              <pre>
              <b>Voir les changements dans un intervalle de branches (par rapport au dernier commit qu'elles pointent).</b>
              Possibilité de faire la comparaison seulement sur certains fichiers ren rajoutant leurs noms à la suite.
              Autre notation : <code>git diff &lt;branche1&gt;..&lt;branche2&gt;</code>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git diff &lt;commit1&gt; &lt;commit2&gt;</code></td>
            <td>
              <pre>
              <b>Voir les changements entre 2 commits.</b>
              Il est aussi possible de ne citer qu'un seul commit ça fera une comparaison entre HEAD et celui-ci. 
              Par exemple <code>git diff HEAD~1</code> va comparer les changements entre le dernier commit et HEAD. 
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="log">
        <thead>
          <tr>
            <th colspan="2">
              <h2>LOG</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git log</code></td>
            <td>
              <pre>
              <b>Afficher un log des commits jusqu'à HEAD.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git log --all</code></td>
            <td>
              <pre>
              <b>Afficher un log de tous les commits.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git log --oneline</code></td>
            <td>
              <pre>
              <b>Formater l'affichage des logs sur une ligne.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git log --graph</code></td>
            <td>
              <pre>
              <b>Afficher une représentation grahique de l'historique des commits.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git log --&lt;nombre&gt;</code></td>
            <td>
              <pre>
              <b>Limite le nombre de commits affichés par rapport au nombre indiqué.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git log &lt;commit-b&gt;..&lt;commit-a&gt;</code></td>
            <td>
              <pre>
              <b>Affiche le log des commits sur la plage donnée.</b>
              Il faut préciser le commit le plus ancien des 2 en premier.
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="push">
        <thead>
          <tr>
            <th colspan="2">
              <h2>PUSH</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git push &lt;label-repo-distant&gt; &lt;branche&gt;</code></td>
            <td>
              <pre>
              <b><branche> 	Va envoyer les mises à jour de la branche locale vers la branche distante.</b>
              Si la liaison entre la branche locale et la branche distante n'a pas encore été faite, on peut rajouter l'argument <code>-u</code>. Suite à ça, si le label de la branche distante est nommée <b>origin</b>, on pourra juste faire la commande <code>git push</code> pour les push suivant via cette branche. Quand le label de la branche distante n'est pas précisé, git utilisera comme valeur par défaut <b>origin</b>, et il pointera la branche distante qui à le même nom que la branche locale.
              Si on ajoute l'argument <code>-f</code> cela aura pour effet d'écraser l'historique de la branche distante par celui en local. Une alternative plus douce est <code>--force-with-lease</code> qui fera le push seulement si la branche distante n'a pas été mise à jour entre temps. Plus d'infos dans cette partie : <a href="#infos">#INFOS</a>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git push &lt;label-repo-distant&gt; -d &lt;branche&gt;</code></td>
            <td>
              <pre>
                <b>Supprimer la branche sur un dépot distant.</b>
                <code>-d</code> peut aussi être noté <code>--delete</code>.
              </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="rebase">
        <thead>
          <tr>
            <th colspan="2">
              <h2>REBASE</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git rebase &lt;branche&gt;</code></td>
            <td>
              <pre>
              <b>Va prendre les commits de notre branche n’étant pas présent dans la branche visée, les ré-appliquer sur celle-ci, à partir de son dernier commit.</b>
              Voir schéma : <a href="#rebase_graph">Schemas REBASE</a>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git rebase -i &lt;ref&gt;</code></td>
            <td>
              <pre>
              <b>Va rebaser les commits de notre branche en fonction de la référence spécifiée</b>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="reflog">
        <thead>
          <tr>
            <th colspan="2">
              <h2>REFLOG</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code></code></td>
            <td>
              <pre>
              <b></b>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="remote">
        <thead>
          <tr>
            <th colspan="2">
              <h2>REMOTE</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git remote</code></td>
            <td>
              <pre>
              <b>Voir les labels des dépots distants liés.</b>
              Pour aussi voir l'url associée aux labels, rajouter <code>-v</code>.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git remote add &lt;label&gt;&lt;repo-url&gt;</code></td>
            <td>
              <pre>
              <b>Lier un dépot distant avec un dépot local.</b>
              La plupart du temps origin sera utilisé comme label. On pourrait utiliser n'importe quel nom à la place mais c'est juste une convention. Quand on clone un repository distant, le label associé à l'url du dépot cloné sera nommé origin automatiquement.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git remote rename &lt;label&gt; &lt;new-label&gt;</new-label></code></td>
            <td>
              <pre>
              <b>Renommer l'ancien label par le nouveau.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git remote remove &lt;label&gt;</code></td>
            <td>
              <pre>
              <b>Supprimer le label et l'url associée.</b>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="reset">
        <thead>
          <tr>
            <th colspan="2">
              <h2>RESET</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git reset &lt;commit&gt;</code></td>
            <td>
              <pre>
              <b>Déplacer HEAD sur un ancien commit en en préservant les modifications effectuées dans le répertoire de travail.</b>
              Si on ne veut pas conserver les changements, on peut rajouter <code>--hard</code>.
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="restore">
        <thead>
          <tr>
            <th colspan="2">
              <h2>RESTORE</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git restore &lt;fichier(s)&gt;</code></td>
            <td>
              <pre>
              <b>Restaurer le contenu d'un ou plusieurs fichier à l'état dans lequel ils sont sur HEAD.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git restore --source &lt;fichier(s)&gt;</code></td>
            <td>
              <pre>
              <b>Restaurer le contenu d'un ou plusieurs fichier en fonction de du commit spécifié.</b>
              Ne va pas modifier les anciens commits.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git restore --staged &lt;fichier(s)&gt;</code></td>
            <td>
              <pre>
              <b>Retirer un ou plusieurs fichier du stage.</b>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="revert">
        <thead>
          <tr>
            <th colspan="2">
              <h2>REVERT</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git revert &lt;commit&gt;</code></td>
            <td>
              <pre>
              <b>Conserver les anciens commits et faire un nouveau commit en retirant les changements induits par le commit ciblé.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git revert &lt;commit-b&gt; &lt;commit-a&gt;</code></td>
            <td>
              <pre>
              <b>Même procédure mais va répéter la même opération sur tous les autres commits ciblés. et fera un nouveau commit à chaque fois.</b>
              Pour ne pas commit les changements, rajouter <code>--no-commit</code>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="stash">
        <thead>
          <tr>
            <th colspan="2">
              <h2>STASH</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git stash</code></td>
            <td>
              <pre>
              <b>Retirer les modifications effectuées sur les fichiers suivis et les ajoute au stash.</b>
              Si on veut également ajouter les fichiers non suivis au stash, rajouter <code>-u</code>.
              Si on veut rajouter un nom à la sauvegarde, rajouter <code>-m "&lt;nom&gt;"</code>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash list</code></td>
            <td>
              <pre>
              <b>Voir la liste des sauvegardes faites dans le stash avec leur id.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash pop</code></td>
            <td>
              <pre>
              <b>Appliquer le contenu de la dernière sauvegarde présente dans le stash sur notre working directory.</b>
              La sauvegarde sera ensuite supprimée du stash.
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash apply</code></td>
            <td>
              <pre>
              <b>Même chose que <code>pop</code> sauf que le la sauvegarde sera conservée dans le stash.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash drop &lt;id&gt;</code></td>
            <td>
              <pre>
              <b>Supprimer la sauvegarde avec l'id pointée du stash.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash clear</code></td>
            <td>
              <pre>
              <b>Supprimer toutes les sauvegardes présentes dans le stash.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git stash show &lt;id&gt;</code></td>
            <td>
              <pre>
              <b>Affiche les modifications de fichier induites dans une sauvegarde.</b>
              Pour afficher un diff, rajouter <code>-p</code>. Si on ne renseigne pas de numéro, la dernière sauvegarde sera choisie.
            </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="switch">
        <thead>
          <tr>
            <th colspan="2">
              <h2>SWITCH</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>git switch &lt;branche&gt;</code></td>
            <td>
              <pre>
              <b>Changer de branche.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git switch -c &lt;branche&gt;</code></td>
            <td>
              <pre>
              <b>	Créer une branche et basculer directement sur celle-ci.</b>
            </pre>
            </td>
          </tr>

          <tr>
            <td><code>git switch -</code></td>
            <td>
              <pre>
            <b>Revenir sur la branche où on était précédemment.</b>
          </pre>
            </td>
          </tr>
        </tbody>
      </table>

      <table id="tag">
        <thead>
          <tr>
            <th colspan="2">
              <h2>TAG</h2>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code></code></td>
            <td>
              <pre>
              <b></b>
            </pre>
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="infos">
      <h2>MORE</h2>
      <article>
        <h3>FAST FORWARD MERGE</h3>
        <div class="graph" id="fast_forward_graph"></div>
      </article>

      <article>
        <h3>MERGE COMMIT</h3>
        <div class="graph" id="merge_commit_graph"></div>
      </article>

      <article>
        <h3>REBASE</h3>
        <div class="graph" id="rebase_graph"></div>
      </article>

      <article class="text" id="undo_commits">
        <h3>ANNULER PLUSIEURS COMMITS</h3>
        <pre>
          Si les commits en question n'ont pas été push sur un repo distant où des personnes travaillent potentiellement dessus, la solution la plus simple serait un <code>git reset &lt;commit-cibl&eacute;&gt;</code>. Dans le cas inverse, il y aurait 2 autres options qui permettraient de garder l'historique intact :
  
          Faire un <code>git revert &lt;dernier-commit-ciblé&gt; &lt;premier-commit-cibl&eacute;&gt;</code>, qui ferait dans l'ordre :
          <ul>
            <li>Annuler les changements induits par le dernier commit ciblé (sans le supprimer), et faire un nouveau commit.</li>
            <li>refaire la même chose mais pour les commits ciblés suivants (du dernier au premier).</li>
            <li>Les inconvénients seraient qu'il' faudrait rajouter un commit supplémentaire par commit ciblé, ce qui peut vite alourdir l'historique.<br> 
              On peut rajouter <code>--no-commit</code> pour seulement avoir à faire un commit nous-même après les actions.
            </li>
          </ul>
          
          Faire un git restore &lt;commit-cibl&eacute;&gt;.
          <ul>
            <li>Cela a pour avantage de le pas cr&eacute;er de potentiels conflits et ne va pas g&eacute;n&eacute;rer plusieurs commits.</li>
          </ul>
        </pre>
      </article>

      <article class="text" id="link_branchs">
        <h3>LIAISON BRANCHE LOCALE/DISTANTE</h3>
        <pre>
          Si on vient de cloner ou fetch un repo distant, les branches distantes seront répertoriées en faisant <code>git branch -r</code> mais aucune branche locale correspondante seront liées à celles-ci.
          Pour éviter de créer une branche nous-même et rentrer une nouvelle commande pour faire la liaison local->distant, on peut simplement effectuer un <code>git switch &lt;nom-branche-distante&gt;</code>  ce qui aura pour effet de créer une branche ayant de meme nom que celle distante et en même temps établir le suivi (fonctionne aussi avec checkout). Cela revient à effectuer un <code>git switch -c &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;&lt;/branch&gt;</code>.
        </pre>
      </article>

      <article class="text" id="link_branchs">
        <h3>GÉRER LES PUSHS FORCÉS</h3>
        <pre>
          Lors d'une tentative de push, si la branche distante n'est pas en mesure de faire un fast-forward pour rattraper notre commit, on aura un message d'erreur. Dans une majorité des cas ça sera car un ou plusieurs commits ont été effectués sur cette branche distante et qu'on ne les possède pas. Il suffira donc de faire un <code>git pull</code>, qui aura pour effet de télécharger les mises à jour, et d'effectuer un merge (ou un rebase si on rajoute <code>--rebase</code>). suite à ça nous pourront effectuer le push.

          Néanmoins, il y a quelques situations où l'on sera contraint de forcer un push. Par exemple, si on décide de rebase des commits qui ont déjà été push, ce qui va créer de nouveaux commits et supprimer les anciens de notre branche locale, mais pas de la branche distante. Pour pallier à cela, il faudra forcer le push avec <code>-f</code>  ou <code>--force</code>. Cela aura pour effet d'écraser les commits présents sur la branche distante par ceux en local. Si on est seul à travailler sur notre branche et qu'on est sûr que personne d'autre va interagir dessus ça peut être une solution.  

          Dans le cas où plusieurs personnes travailleraient sur cette branche, utiliser <code>--force</code> serait risqué car on pourrait écraser des commits effectués par des collègues en pensant que la seule raison du refus de push est le rebase qu'on a effectué. Une solution plus douce existe : <code>--force-with-lease</code>. Ce que va faire cette commande, c'est comparer la référence du dernier commit sur le repository distant, et la comparer avec la référence de la branche suivie à distance en locale. Pour illustrer, si par exemple la branche feature distante a pour dernier commit af43d00, et qu'en local, notre origin/feature pointe sur un hash différent, cela voudrait dire que la branche distante à été mise à jour depuis la dernière fois qu'on l'a fetch. Le push avec <code>--force-with-lease</code> ne sera pas effectué et on sera invité à faire un pull pour récupérer les dernières mises à jour avant de re-essayer. Un simple <code>--force</code> aurait permit ce push et aurait écrasé le commit af43d00 ainsi que tout ceux qui n'ont pas été fetch.
        </pre>
      </article>
    </section>
  </main>
  <script src="./script.js" type="module"></script>
</body>

</html>